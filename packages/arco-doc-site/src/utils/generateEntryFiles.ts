import fs from 'fs-extra';
import path from 'path';
import glob from 'glob';
import { print } from '@arco-design/arco-dev-utils';
import getMainConfig from './getMainConfig';
import { PLACEHOLDER_ARCO_SITE_MODULE_INFO } from '../constant';

export const LIBRARY_MODULE_NAME = 'arcoSite';
const VARIABLE_PREFIX = LIBRARY_MODULE_NAME;

const { build: buildConfig, site: siteConfig } = getMainConfig();
const entryFileDir = path.resolve('__temp__');

export function getPathEntryByLanguage(language: string) {
  return path.resolve(entryFileDir, `index.js`.replace(/.js$/, `.${language}.js`));
}

export default function generateEntryFiles() {
  if (!buildConfig || !buildConfig.globs || !buildConfig.globs.component) {
    print.error('[arco-doc-site]', `Failed to get glob info of component, check your config file.`);
    process.exit(0);
  }

  const getRequirePath = (absolutePath) => {
    return path.relative(entryFileDir, absolutePath).replace(/^[^.]/, (str) => `./${str}`);
  };

  const generateEntry = (language) => {
    const entryFilePath = getPathEntryByLanguage(language);
    const exportModuleInfoList: Array<{
      name: string;
      statement: string;
    }> = [];

    // Final content of entry file
    const fileContent = [
      `// Do NOT edit this file manually, it's generated by @arco-design/arco-doc-site.

/* eslint-disable */

function decodeInfo(infoStr) {
  try {
    const decoder = new TextDecoder();
    const jsonStr = decoder.decode(new Uint8Array(infoStr.split(',')));
    return JSON.parse(jsonStr);
  } catch (e) {}

  return {};
}

const moduleInfoStr = '${PLACEHOLDER_ARCO_SITE_MODULE_INFO}';
const ${LIBRARY_MODULE_NAME} = {};
`,
    ];

    exportModuleInfoList.push({
      name: `${VARIABLE_PREFIX}ModuleInfo`,
      statement: 'decodeInfo(moduleInfoStr)',
    });

    exportModuleInfoList.push({
      name: `${VARIABLE_PREFIX}Config`,
      statement: JSON.stringify(siteConfig, null, 2).replace(/^"(.*)"$/s, (_, $1) => $1),
    });

    // Import hook
    const hookNameList: string[] = [];
    Object.entries(buildConfig.globs.hook || {}).forEach(([hookName, hookPattern]) => {
      const [hookPath] = glob.sync(hookPattern);
      if (hookPath) {
        hookNameList.push(hookName);
        fileContent.push(`import ${hookName} from '${getRequirePath(hookPath)}';`);
      }
    });
    if (hookNameList.length) {
      exportModuleInfoList.push({
        name: `${VARIABLE_PREFIX}Hook`,
        statement: `{ ${hookNameList.join(', ')} }`,
      });
    }

    // Import pure markdown
    glob.sync(buildConfig.globs.doc).forEach((p, index) => {
      if (p.indexOf(language) > -1 && fs.existsSync(p)) {
        const componentName = `Doc${index}`;
        const statement = `_${componentName}`;
        fileContent.push(
          `
// Import document from ${p}
import * as ${statement} from '${getRequirePath(p)}';
`
        );
        exportModuleInfoList.push({
          name: componentName,
          statement,
        });
      }
    });

    // Import component demos
    glob
      .sync(buildConfig.globs.component.base)
      .map((p) => {
        const { demo, doc, style } = buildConfig.globs.component;
        return {
          componentName: path.basename(p).replace(/-(\w)/g, (_, $1) => $1.toUpperCase()),
          pathDemo: demo && path.resolve(p, demo),
          pathDoc: doc && path.resolve(p, doc),
          pathStyle: style && path.resolve(p, style),
        };
      })
      .forEach(({ componentName: moduleName, pathDemo, pathDoc, pathStyle }) => {
        let demoModuleName;
        let docModuleName;
        const tempFileContent = [`// Import demos and document of ${moduleName}`];

        if (fs.existsSync(pathDemo)) {
          demoModuleName = `_${moduleName}`;
          tempFileContent.push(`import * as ${demoModuleName} from '${getRequirePath(pathDemo)}';`);
        }

        if (fs.existsSync(pathDoc)) {
          docModuleName = `_${moduleName}Doc`;
          tempFileContent.push(`import ${docModuleName} from '${getRequirePath(pathDoc)}';`);
        }

        if (buildConfig.withMaterialStyle && fs.existsSync(pathStyle)) {
          tempFileContent.push(`import '${pathStyle}';`);
        }

        if (demoModuleName || docModuleName) {
          fileContent.push(`\n${tempFileContent.join('\n')}\n`);
          exportModuleInfoList.push({
            name: moduleName,
            statement: `{ ${demoModuleName ? `...${demoModuleName}, ` : ''}${
              docModuleName ? `_SITE_DOC: ${docModuleName} ` : ''
            }}`,
          });
        }
      });

    const exportExpressions = exportModuleInfoList
      .map(({ name, statement }) => {
        return `export const ${name} = ${statement};\n${LIBRARY_MODULE_NAME}.${name} = ${name};\n`;
      })
      .join('\n');

    fileContent.push(`
// Export submodules
${exportExpressions}

// Only used by team site development mode
if (window.arcoMaterialTeamSite && window.arcoMaterialTeamSite.renderPage) {
  const siteDevOptions = ${JSON.stringify(buildConfig.devOptions || {}, null, 2).replace(
    /^"(.*)"$/s,
    (_, $1) => $1
  )};
  window.arcoMaterialTeamSite.renderPage(${LIBRARY_MODULE_NAME}, siteDevOptions);
}
`);

    fs.ensureDirSync(entryFileDir);
    fs.writeFileSync(entryFilePath, fileContent.join('\n'));
  };

  siteConfig.languages.forEach(generateEntry);
}
